<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SciConNav 3D Visualization (Sci-Fi Theme)</title>
    <style>
        /* ======= DARK SCI FI THEME (Adapted from realdeepresearch) ======= */
        :root {
            --color-primary: #4aa8ff;
            --color-primary-light: #6cb7ff;
            --color-primary-bg: rgba(74, 168, 255, 0.06);
            --color-primary-border: rgba(74, 168, 255, 0.28);
            --color-text: #e8eaed;
            --color-text-secondary: #a2a7b0;
            --color-text-tertiary: #6c7380;
            --color-border: #2b2f3a;
            --color-border-light: #232733;
            --color-bg: #000000;
            --color-bg-elevated: #12141a;
            --color-bg-secondary: #171b23;
            --color-bg-hover: #1d2230;

            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.5);
            --shadow-md: 0 6px 18px rgba(0, 0, 0, 0.6);
            
            --radius-md: 10px;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", sans-serif;
            background-color: var(--color-bg); 
            color: var(--color-text); 
            -webkit-font-smoothing: antialiased;
        }
        
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* UI Container styled like .card in part1.html */
        #ui-container {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(18, 20, 26, 0.0);
            backdrop-filter: none;
            border: 1px solid rgba(43, 47, 58, 0.0);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            padding: 20px;
            max-width: 320px; /* Increased width to prevent text wrapping */
            transition: transform 0.3s ease;
            z-index: 10;
            color: var(--color-text);
        }
        
        #ui-container.minimized {
            transform: translate(120%, -50%);
        }
        
        #ui-toggle {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            z-index: 100;
            background: rgba(18, 20, 26, 0.92);
            border: 1px solid var(--color-border);
            color: var(--color-text);
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            display: none;
            backdrop-filter: blur(12px);
        }
        
        #ui-container.minimized + #ui-toggle {
            display: block;
        }
        
        /* SciConNav Title Style from indexds.html */
        h1 { margin: 0 0 15px 0; font-size: 1.5rem; font-weight: 600; letter-spacing: 0.5px; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .control-group { margin-bottom: 15px; }
        
        label { 
            display: block; 
            margin-bottom: 5px; 
            font-size: 0.85rem; 
            color: var(--color-text-secondary); 
            font-weight: 600;
        }
        
        select, input[type="text"] {
            width: 100%;
            padding: 8px 12px;
            background: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            color: var(--color-text);
            font-size: 0.9rem;
            outline: none;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        
        select:focus, input[type="text"]:focus { 
            border-color: var(--color-primary-border); 
            background: var(--color-bg-hover);
        }
        
        .legend { display: flex; flex-wrap: wrap; gap: 5px; max-height: none; overflow-y: visible; margin-top: 10px; padding-right: 5px; }
        
        .legend-item { 
            display: flex; 
            align-items: center; 
            font-size: 0.8rem; 
            width: 48%; 
            cursor: pointer; 
            padding: 4px 6px; 
            border-radius: 4px; 
            transition: all 0.2s; 
            border: 1px solid transparent;
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .legend-item:hover { 
            background: var(--color-bg-hover); 
            border-color: var(--color-primary-border);
        }
        
        .legend-color { 
            width: 10px; 
            height: 10px; 
            border-radius: 50%; /* Circle like indexds.html */
            margin-right: 8px; 
            flex-shrink: 0; 
            border: 1px solid rgba(255,255,255,0.15);
        }
        
        .legend-item.inactive { opacity: 0.4; }
        
        #loading {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: var(--color-bg);
            z-index: 1000;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--color-border-light);
            border-radius: 50%;
            border-top-color: var(--color-primary);
            animation: spin 0.8s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        #loading-text { font-size: 1.2rem; color: var(--color-text); font-weight: 700; }
        #loading-progress { font-size: 0.9rem; color: var(--color-text-secondary); margin-top: 5px; }

        #tooltip {
            position: absolute;
            background: rgba(18, 20, 26, 0.95);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--color-primary-border);
            pointer-events: none;
            display: none;
            font-size: 0.9rem;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            max-width: 250px;
            backdrop-filter: blur(12px);
        }
        
        #tooltip h3 { margin: 0 0 5px 0; font-size: 1rem; color: var(--color-primary-light); }
        #tooltip p { margin: 3px 0; color: var(--color-text-secondary); }
        .highlight { color: var(--color-text); font-weight: bold; }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #3a404e; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #5a6173; }

        #search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(18, 20, 26, 0.98);
            border: 1px solid var(--color-border);
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 10;
            box-shadow: var(--shadow-md);
        }
        
        .search-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--color-border-light);
            color: var(--color-text);
        }
        
        .search-item:hover { 
            background: var(--color-bg-hover);
            color: var(--color-primary);
        }
        
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--color-border);
            font-size: 0.8rem;
            color: var(--color-text-tertiary);
            display: flex;
            justify-content: space-between;
        }
        
        /* Color Schemes Style from indexds.html */
        #color-schemes {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.0);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: none;
            border: 1px solid rgba(255, 255, 255, 0.0);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 80%;
            z-index: 10;
        }

        #dimension-controls {
            position: absolute;
            bottom: 80px; /* Above color schemes */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.0);
            padding: 10px;
            border-radius: 12px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 80%;
            z-index: 10;
        }

        .dim-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--color-text-secondary);
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .dim-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--color-text);
        }

        .dim-btn.active {
            background: var(--color-primary-bg);
            border-color: var(--color-primary-border);
            color: var(--color-primary);
            box-shadow: 0 0 10px rgba(74, 168, 255, 0.3);
        }
        
        .color-scheme-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 6px;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .color-scheme-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.05);
        }
        
        .color-scheme-btn.active {
            background: rgba(79, 172, 254, 0.3);
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
        }
        
        .color-scheme-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            margin-right: 5px;
        }
        
        .color-scheme-label {
            color: white;
            font-size: 0.8rem;
        }

        .view-toggles {
            display: flex;
            gap: 10px;
        }
        .view-btn {
            flex: 1;
            padding: 8px;
            background: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            color: var(--color-text-secondary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            font-size: 0.85rem;
        }
        .view-btn.active {
            background: var(--color-primary-bg);
            border-color: var(--color-primary-border);
            color: var(--color-primary);
            box-shadow: inset 0 0 0 1px var(--color-primary-border);
        }
        .view-btn:hover:not(.active) {
            background: var(--color-bg-hover);
            color: var(--color-primary);
        }
        
        /* Close button style */
        .close-btn {
            background: none;
            border: none;
            color: var(--color-text-tertiary);
            cursor: pointer;
            font-size: 1.2rem;
            transition: color 0.2s;
        }
        .close-btn:hover { color: var(--color-text); }
        
        a { color: var(--color-primary); text-decoration: none; transition: color 0.2s; }
        a:hover { color: var(--color-primary-light); text-decoration: underline; }

        #help-text {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #ff5555; /* Red font */
            font-size: 0.75rem;
            background: transparent; /* Fully transparent */
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="help-text">1. Scroll to Zoom<br>2. Ctrl + Left Click to Move</div>
    
    <div id="loading">
        <div style="text-align: center;">
            <div class="spinner"></div>
            <div id="loading-text">Loading SciConNav Universe</div>
            <div id="loading-progress">Initializing...</div>
        </div>
    </div>

    <div id="ui-toggle" onclick="toggleUI()">☰ Controls</div>

    <div id="ui-container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h1>SciConNav</h1>
            <button onclick="toggleUI()" class="close-btn">×</button>
        </div>
        
        <div class="control-group search-container">
            <label for="search-input">Search Concept</label>
            <input type="text" id="search-input" placeholder="Type to search...">
            <div id="search-results"></div>
        </div>

        <div class="control-group">
            <label for="level-filter">Level Filter (Depth)</label>
            <select id="level-filter">
                <option value="all">All Levels</option>
                <option value="0">Level 0 (Roots)</option>
                <option value="1">Level 1</option>
                <option value="2">Level 2</option>
                <option value="3">Level 3</option>
                <option value="4">Level 4</option>
                <option value="5">Level 5</option>
            </select>
        </div>

        <div class="control-group">
            <label>View Mode</label>
            <div class="view-toggles">
                <button class="view-btn active" id="btn-3d" onclick="setMode('3d')">3D View</button>
                <button class="view-btn" id="btn-2d" onclick="setMode('2d')">2D View</button>
            </div>
        </div>

        <div class="control-group">
            <label>Controls</label>
            <div class="view-toggles">
                <button class="view-btn active" id="btn-autorotate" onclick="toggleAutoRotate()">Auto Rotate: ON</button>
            </div>
        </div>

        <div class="control-group">
            <label>Disciplines (Hover to Highlight)</label>
            <div style="margin-bottom: 5px; font-size: 0.8rem;">
                <a href="#" onclick="toggleAllDisciplines(true); return false;">Select All</a> |
                <a href="#" onclick="toggleAllDisciplines(false); return false;">Deselect All</a>
            </div>
            <div id="legend" class="legend"></div>
        </div>

        <div class="stats">
            <span id="visible-count">0 visible</span>
            <span id="total-count">0 total</span>
        </div>
    </div>

    <div id="tooltip"></div>
    
    <div id="dimension-controls">
        <!-- Dimension buttons will be inserted here -->
    </div>

    <div id="color-schemes">
        <!-- Color scheme buttons will be inserted here by JavaScript -->
    </div>

    <!-- Import Maps Polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
        import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
        import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

        // Palette from realdeepresearch.github.io/part1.html
        const BASE_PALETTE = [
          "#F2B44B","#8CCEF4","#33C6A0","#F5ED72","#4FA3D6","#E6843F","#E1A8CC","#BFBFBF",
          "#7A6AD6","#78C8BE","#4AA17E","#B5E3F7","#E9DFA0","#E19AA7","#C97AC0","#B26686",
          "#995533","#9FC0E3","#CC7C98","#7FA3CF","#57B06A","#F29CA6"
        ];

        const CONFIG = {
            binaryPath: 'data/concept_coordinates.bin',
            metaPath: 'data/concept_coordinates_meta.json',
            namesPath: 'data/concept_coordinates_meta.json',
            colorsPath: 'data/color_schemes.json',
            pointSize: 0.012, // Slightly smaller than 0.015/0.018
        };

        const state = {
            metadata: null,
            colorSchemes: null,
            activeDisciplines: new Set(),
            activeLevel: 'all',
            activeScheme: 'part1', // Default to part1 scheme
            viewMode: '3d',
            autoRotate: true,
            hoveredDiscipline: null,
            pointsData: null, // Holds raw data
            dataCenter: null, // Will hold {x, y, z, maxDim}
            activeDimension: null, // Currently selected dimension
            availableDimensions: [], // List of available dimensions
            multiDimData3D: null, // Holds all 3D dimension data
            multiDimData2D: null, // Holds all 2D dimension data
            axisObjects: [], // Holds axis meshes to remove them on update
        };

        // Three.js globals
        let scene, camera, renderer, composer, controls;
        let pointsMesh; // InstancedMesh
        let raycaster, mouse;
        let hoveredInstanceId = -1;
        let marker;

        const updateProgress = (msg) => {
            console.log(msg);
            document.getElementById('loading-progress').innerText = msg;
        };

        async function loadData() {
            try {
                updateProgress("Loading metadata...");
                const metaRes = await fetch(CONFIG.metaPath);
                state.metadata = await metaRes.json();

                updateProgress("Loading color schemes...");
                const colorsRes = await fetch(CONFIG.colorsPath);
                const loadedSchemes = await colorsRes.json();
                
                // Inject part1 palette into schemes
                state.colorSchemes = loadedSchemes;
                state.colorSchemes.schemes['part1'] = BASE_PALETTE;
                state.colorSchemes.names['part1'] = "Sci-Fi Palette";

                updateProgress("Loading 3D coordinates...");
                const binRes = await fetch(CONFIG.binaryPath);
                const buffer = await binRes.arrayBuffer();

                // Parse multi-dimension binary data
                const headerView = new Uint32Array(buffer, 0, 2);
                const n_points = headerView[0];
                const n_dims = headerView[1];
                
                const dimsView = new Uint32Array(buffer, 8, n_dims);
                state.availableDimensions = Array.from(dimsView);
                state.activeDimension = state.availableDimensions[state.availableDimensions.length - 1]; // Default to highest dim (usually best quality)
                
                console.log(`Loaded ${n_points} points with ${n_dims} dimensions:`, state.availableDimensions);
                
                // Calculate offset to start of point data
                // Header: 4 bytes (n_points) + 4 bytes (n_dims) + 4*n_dims bytes (dim values)
                const headerSize = 8 + (4 * n_dims);
                
                // Each point has: 4 bytes (disc) + 4 bytes (level) + n_dims * (12 bytes 3D + 8 bytes 2D)
                const pointSize = 8 + (n_dims * 20);
                
                // Pre-allocate arrays for all dimensions
                state.multiDimData3D = {};
                state.multiDimData2D = {};
                for (const dim of state.availableDimensions) {
                    state.multiDimData3D[dim] = new Float32Array(n_points * 3);
                    state.multiDimData2D[dim] = new Float32Array(n_points * 3); // Use 3 components for 2D (z=0)
                }
                
                const disciplines = new Uint8Array(n_points);
                const levels = new Uint8Array(n_points);
                
                const dataView = new DataView(buffer);
                let offset = headerSize;
                
                for (let i = 0; i < n_points; i++) {
                    disciplines[i] = dataView.getUint32(offset, true);
                    offset += 4;
                    levels[i] = dataView.getUint32(offset, true);
                    offset += 4;
                    
                    for (const dim of state.availableDimensions) {
                        // Read 3D
                        const x3 = dataView.getFloat32(offset, true);
                        const y3 = dataView.getFloat32(offset + 4, true);
                        const z3 = dataView.getFloat32(offset + 8, true);
                        offset += 12;
                        
                        const target3D = state.multiDimData3D[dim];
                        target3D[i * 3] = x3;
                        target3D[i * 3 + 1] = y3;
                        target3D[i * 3 + 2] = z3;

                        // Read 2D
                        const x2 = dataView.getFloat32(offset, true);
                        const y2 = dataView.getFloat32(offset + 4, true);
                        offset += 8;

                        const target2D = state.multiDimData2D[dim];
                        target2D[i * 3] = x2;
                        target2D[i * 3 + 1] = y2;
                        target2D[i * 3 + 2] = 0; // Z is 0 for 2D view
                    }
                }

                // Set initial points data
                state.pointsData = {
                    positions: state.viewMode === '2d' ? state.multiDimData2D[state.activeDimension] : state.multiDimData3D[state.activeDimension],
                    disciplines,
                    levels,
                    count: n_points
                };
                
                updateDataCenter();
                setupDimensionUI();
                updateAxes();
                updateCameraTarget();

                // Initialize active disciplines
                for (let i = 0; i < state.metadata.n_disciplines; i++) {
                    state.activeDisciplines.add(i);
                }

                document.getElementById('total-count').innerText = `${n_points.toLocaleString()} total`;

            } catch (error) {
                console.error("Error loading data:", error);
                updateProgress(`Error: ${error.message}`);
                throw error;
            }
        }

        function initThree() {
            const container = document.getElementById("canvas-container");

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            // part1.html doesn't use fog, but indexds did. Let's remove fog to match part1's crisp look or keep it minimal.
            // scene.fog = new THREE.FogExp2(0x000000, 0.002); 

            // Camera
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 2000);
            
            // Renderer (Matched part1.html)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.25;
            container.appendChild(renderer.domElement);

            // Post-processing (Bloom) (Matched part1.html)
            const renderScene = new RenderPass(scene, camera);
            // Reduced bloom strength to prevent colors from blowing out to white
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.4, 0.45, 0.1);
            // strength 0.4 (was 0.8), radius 0.45, threshold 0.1 (was 0.02)

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = state.autoRotate;
            controls.autoRotateSpeed = 0.45; // Slower rotation like part1
            
            // Allow full rotation without limits
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.05);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x73b2ff, 0.6, 60, 2); // Blueish light from part1
            pointLight.position.set(10, 12, 8);
            scene.add(pointLight);

            // Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Marker for hover
            const markerGeom = new THREE.SphereGeometry(CONFIG.pointSize * 1.6, 16, 16);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.75 });
            marker = new THREE.Mesh(markerGeom, markerMat);
            marker.visible = false;
            scene.add(marker);

            // Events
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onClick);
        }

        function createPoints() {
            if (pointsMesh) {
                scene.remove(pointsMesh);
                pointsMesh.geometry.dispose();
                pointsMesh.material.dispose();
            }

            const geometry = new THREE.SphereGeometry(CONFIG.pointSize, 10, 10); // Higher segments like part1
            
            // Material matched to part1.html but adjusted for color visibility
            // We use a custom shader approach via onBeforeCompile or simply rely on vertex colors
            // For standard material, if we want the color to shine through without light, we need some emissive
            // BUT we need the emissive color to match the instance color, which isn't automatic in standard material without custom shader.
            // A simpler fix for "nebula" look is to use MeshBasicMaterial or high ambient light,
            // OR use vertex colors for emissive if possible (not standard in Three.js InstancedMesh without tweaks).
            
            // Let's try a balanced approach: Use MeshBasicMaterial for pure color visibility (like a point cloud),
            // or MeshLambert with high ambient. Given the "nebula" request, Basic is often best for glowing points.
            
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff, // Will be tinted by instanceColor
                transparent: true,
                opacity: 0.6 // Reduced opacity to prevent white washout from overlapping points
            });

            pointsMesh = new THREE.InstancedMesh(geometry, material, state.pointsData.count);
            pointsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            pointsMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(state.pointsData.count * 3), 3);

            updatePointsVisuals();
            scene.add(pointsMesh);
        }

        function updatePointsVisuals() {
            if (!pointsMesh) return;

            // Ensure we are using the correct positions based on current mode
            const positions = state.viewMode === '2d' ?
                state.multiDimData2D[state.activeDimension] :
                state.multiDimData3D[state.activeDimension];
                
            const { disciplines, levels, count } = state.pointsData;
            const scheme = state.colorSchemes.schemes[state.activeScheme];
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            
            let visibleCount = 0;

            for (let i = 0; i < count; i++) {
                const discId = disciplines[i];
                const level = levels[i];
                
                // Visibility Logic
                const isDiscVisible = state.activeDisciplines.has(discId);
                const isLevelVisible = state.activeLevel === 'all' || level === parseInt(state.activeLevel);
                const isVisible = isDiscVisible && isLevelVisible;

                // Highlight Logic
                let scale = 1.0;
                if (state.hoveredDiscipline !== null && state.hoveredDiscipline !== discId) {
                    scale = 0.0; // Hide non-highlighted disciplines
                } else if (!isVisible) {
                    scale = 0.0;
                }

                if (scale > 0) visibleCount++;

                // Position
                dummy.position.set(positions[i*3], positions[i*3+1], positions[i*3+2]);
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
                pointsMesh.setMatrixAt(i, dummy.matrix);

                // Color
                const colorStr = scheme[discId % scheme.length] || '#ffffff';
                color.set(colorStr);
                
                // Increase saturation/brightness of the color itself since we removed emissive white
                // This helps the colors pop without being washed out by white light
                pointsMesh.setColorAt(i, color);
            }

            pointsMesh.instanceMatrix.needsUpdate = true;
            pointsMesh.instanceColor.needsUpdate = true;
            
            document.getElementById('visible-count').innerText = `${visibleCount.toLocaleString()} visible`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Only intersect if points exist
            if (pointsMesh) {
                const intersection = raycaster.intersectObject(pointsMesh);

                if (intersection.length > 0) {
                    const instanceId = intersection[0].instanceId;
                    
                    // Check if point is actually visible (scale > 0)
                    const matrix = new THREE.Matrix4();
                    pointsMesh.getMatrixAt(instanceId, matrix);
                    const scale = new THREE.Vector3();
                    scale.setFromMatrixScale(matrix);

                    if (scale.x > 0.1) {
                        hoveredInstanceId = instanceId;
                        
                        // Show marker
                        const pos = new THREE.Vector3();
                        pos.setFromMatrixPosition(matrix);
                        marker.position.copy(pos);
                        marker.visible = true;
                        
                        // Show tooltip
                        showTooltip(instanceId, event.clientX, event.clientY);
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            hoveredInstanceId = -1;
            marker.visible = false;
            hideTooltip();
            document.body.style.cursor = 'default';
        }

        function onClick(event) {
            if (hoveredInstanceId !== -1) {
                // Handle click (e.g., focus or log)
                console.log("Clicked point:", hoveredInstanceId);
            }
        }

        function showTooltip(index, x, y) {
            const tooltip = document.getElementById('tooltip');
            // Get concept name from metadata
            const name = state.metadata.concept_names ? state.metadata.concept_names[index] : `Concept ${index}`;
            const discId = state.pointsData.disciplines[index];
            const level = state.pointsData.levels[index];
            const discipline = state.metadata.discipline_names[discId];
            const scheme = state.colorSchemes.schemes[state.activeScheme];
            const colorStr = scheme[discId % scheme.length] || '#ffffff';
            
            tooltip.style.display = 'block';
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y - 15) + 'px';
            
            tooltip.innerHTML = `
                <h3>${name}</h3>
                <p><span class="highlight" style="color:${colorStr}">●</span> <span class="highlight">Discipline:</span> ${discipline}</p>
                <p><span class="highlight">Level:</span> ${level}</p>
            `;
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            composer.render();
        }

        // --- UI Logic (Adapted from original) ---

        window.toggleUI = function() {
            const ui = document.getElementById('ui-container');
            ui.classList.toggle('minimized');
        }

        window.setMode = function(mode) {
            state.viewMode = mode;
            document.getElementById('btn-2d').classList.toggle('active', mode === '2d');
            document.getElementById('btn-3d').classList.toggle('active', mode === '3d');
            
            // Update data source based on mode
            if (state.activeDimension) {
                state.pointsData.positions = mode === '2d' ?
                    state.multiDimData2D[state.activeDimension] :
                    state.multiDimData3D[state.activeDimension];
                
                updateDataCenter();
                updatePointsVisuals();
                updateAxes();
            }

            if (mode === '2d') {
                controls.autoRotate = false;
                controls.enableRotate = false; // Lock rotation
                
                // Reset camera for 2D view
                if (state.dataCenter) {
                    const { x, y, z, maxDim } = state.dataCenter;
                    // Center camera on data
                    controls.target.set(x, y, z);
                    camera.position.set(x, y, z + maxDim * 1.2); // Zoom out enough to see everything
                    camera.lookAt(x, y, z);
                }
            } else {
                controls.enableRotate = true;
                controls.autoRotate = state.autoRotate;
                updateCameraTarget(); // Reset 3D camera view
            }
        };

        window.toggleAutoRotate = function() {
            state.autoRotate = !state.autoRotate;
            controls.autoRotate = state.autoRotate;
            const btn = document.getElementById('btn-autorotate');
            btn.innerText = state.autoRotate ? "Auto Rotate: ON" : "Auto Rotate: OFF";
            btn.classList.toggle('active', state.autoRotate);
        };

        window.toggleAllDisciplines = function(enable) {
            const legendItems = document.querySelectorAll('.legend-item');
            if (enable) {
                for (let i = 0; i < state.metadata.n_disciplines; i++) state.activeDisciplines.add(i);
                legendItems.forEach(el => el.classList.remove('inactive'));
            } else {
                state.activeDisciplines.clear();
                legendItems.forEach(el => el.classList.add('inactive'));
            }
            updatePointsVisuals();
        }

        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';
            const disciplines = state.metadata.discipline_names;
            const scheme = state.colorSchemes.schemes[state.activeScheme];
            
            disciplines.forEach((name, idx) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                if (!state.activeDisciplines.has(idx)) {
                    item.classList.add('inactive');
                }
                item.dataset.id = idx;
                
                const colorStr = scheme[idx % scheme.length] || '#ffffff';
                
                item.innerHTML = `
                    <div class="legend-color" style="background-color: ${colorStr}"></div>
                    <span title="${name}">${name}</span>
                `;
                
                item.onclick = () => toggleDiscipline(idx, item);
                
                item.onmouseenter = () => {
                    state.hoveredDiscipline = idx;
                    updatePointsVisuals();
                };
                item.onmouseleave = () => {
                    state.hoveredDiscipline = null;
                    updatePointsVisuals();
                };

                legend.appendChild(item);
            });
        }

        function toggleDiscipline(id, element) {
            if (state.activeDisciplines.has(id)) {
                state.activeDisciplines.delete(id);
                element.classList.add('inactive');
            } else {
                state.activeDisciplines.add(id);
                element.classList.remove('inactive');
            }
            updatePointsVisuals();
        }

        function setupUI() {
            document.getElementById('level-filter').addEventListener('change', (e) => {
                state.activeLevel = e.target.value;
                updatePointsVisuals();
            });

            // Color Schemes
            const schemesContainer = document.getElementById('color-schemes');
            const schemes = state.colorSchemes.schemes;
            const schemeNames = state.colorSchemes.names;
            
            Object.keys(schemes).forEach((schemeKey) => {
                const scheme = schemes[schemeKey];
                const schemeName = schemeNames[schemeKey];
                
                const button = document.createElement('button');
                button.className = 'color-scheme-btn';
                button.dataset.scheme = schemeKey;
                button.title = schemeName;
                
                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'color-scheme-color';
                if (scheme && scheme.length > 0) {
                    colorSwatch.style.backgroundColor = scheme[0];
                }
                
                const label = document.createElement('span');
                label.className = 'color-scheme-label';
                label.textContent = schemeName;
                
                button.appendChild(colorSwatch);
                button.appendChild(label);
                
                button.addEventListener('click', () => {
                    state.activeScheme = schemeKey;
                    updateLegend();
                    updatePointsVisuals();
                    updateSchemeButtons();
                });
                
                schemesContainer.appendChild(button);
            });
            
            updateSchemeButtons();
            updateLegend();

            // Search
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');
            
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                if (query.length < 2) {
                    searchResults.style.display = 'none';
                    return;
                }
                
                const matches = [];
                if (state.metadata.concept_names) {
                    const names = state.metadata.concept_names;
                    
                    for (let i = 0; i < names.length; i++) {
                        if (names[i].toLowerCase().includes(query)) {
                            matches.push({ name: names[i], index: i });
                            if (matches.length >= 10) break;
                        }
                    }
                }
                
                if (matches.length > 0) {
                    searchResults.innerHTML = matches.map(m =>
                        `<div class="search-item" onclick="focusOnConcept(${m.index})">${m.name}</div>`
                    ).join('');
                    searchResults.style.display = 'block';
                } else {
                    searchResults.style.display = 'none';
                }
            });

            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-container')) {
                    searchResults.style.display = 'none';
                }
            });
        }

        window.focusOnConcept = function(index) {
            // Find position
            const x = state.pointsData.positions[index * 3];
            const y = state.pointsData.positions[index * 3 + 1];
            const z = state.pointsData.positions[index * 3 + 2];

            // Move camera to focus
            const target = new THREE.Vector3(x, y, z);
            const offset = new THREE.Vector3(0, 0, 5); // Distance from point
            
            // Animate camera (simple lerp could be added here, but direct set for now)
            controls.target.copy(target);
            camera.position.copy(target).add(offset);
            controls.update();

            // Highlight
            hoveredInstanceId = index;
            marker.position.set(x, y, z);
            marker.visible = true;

            document.getElementById('search-results').style.display = 'none';
            const name = state.metadata.concept_names ? state.metadata.concept_names[index] : `Concept ${index}`;
            document.getElementById('search-input').value = name;
        }

        function updateSchemeButtons() {
            document.querySelectorAll('.color-scheme-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.querySelector(`.color-scheme-btn[data-scheme="${state.activeScheme}"]`);
            if (activeBtn) activeBtn.classList.add('active');
        }

        function updateDataCenter() {
            const positions = state.pointsData.positions;
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            for (let i = 0; i < state.pointsData.count; i++) {
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                const z = positions[i * 3 + 2];
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
                if (z < minZ) minZ = z;
                if (z > maxZ) maxZ = z;
            }

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxDim = Math.max(sizeX, sizeY, sizeZ);

            state.dataCenter = { x: centerX, y: centerY, z: centerZ, maxDim };
        }

        function updateAxes() {
            // Remove old axes
            state.axisObjects.forEach(obj => scene.remove(obj));
            state.axisObjects = [];

            const { x: centerX, y: centerY, z: centerZ, maxDim } = state.dataCenter;

            // Add Axes with Arrows
            const axisLength = maxDim * 0.6; 
            const headLength = axisLength * 0.05;
            const headWidth = headLength * 0.5;
            const origin = new THREE.Vector3(centerX, centerY, centerZ);

            // X Axis (Red)
            const arrowX = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), origin, axisLength, 0xff5555, headLength, headWidth);
            scene.add(arrowX);
            state.axisObjects.push(arrowX);
            
            // Y Axis (Green)
            const arrowY = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), origin, axisLength, 0x55ff55, headLength, headWidth);
            scene.add(arrowY);
            state.axisObjects.push(arrowY);
            
            // Z Axis (Blue)
            const arrowZ = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), origin, axisLength, 0x5555ff, headLength, headWidth);
            scene.add(arrowZ);
            state.axisObjects.push(arrowZ);

            // Add Axis Labels (X, Y, Z)
            const createLabel = (text, color, pos) => {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.font = 'bold 48px sans-serif';
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(pos);
                const scale = maxDim * 0.04;
                sprite.scale.set(scale, scale, 1);
                return sprite;
            };

            const labelOffset = maxDim * 0.05;
            const labelX = createLabel("X", "#ff5555", new THREE.Vector3(centerX + axisLength + labelOffset, centerY, centerZ));
            scene.add(labelX);
            state.axisObjects.push(labelX);

            const labelY = createLabel("Y", "#55ff55", new THREE.Vector3(centerX, centerY + axisLength + labelOffset, centerZ));
            scene.add(labelY);
            state.axisObjects.push(labelY);

            // Only show Z label in 3D mode
            if (state.viewMode === '3d') {
                const labelZ = createLabel("Z", "#5555ff", new THREE.Vector3(centerX, centerY, centerZ + axisLength + labelOffset));
                scene.add(labelZ);
                state.axisObjects.push(labelZ);
            }
        }

        function updateCameraTarget() {
             const { x: centerX, y: centerY, z: centerZ, maxDim } = state.dataCenter;
             
             // Move content UP by looking LOWER (decrease Y target)
             // Zoom IN by decreasing Z distance
             // Adjusted to 0.15 offset and 15 distance for larger view
             const viewTargetY = centerY - (maxDim * 0.15);
             
             controls.target.set(centerX, viewTargetY, centerZ);
             
             // Reset camera position relative to new center to ensure "zoom" is correct.
             camera.position.set(centerX, viewTargetY, centerZ + 15);
             controls.update();
        }

        function setupDimensionUI() {
            const container = document.getElementById('dimension-controls');
            container.innerHTML = '';
            
            state.availableDimensions.forEach(dim => {
                const btn = document.createElement('button');
                btn.className = 'dim-btn';
                if (dim === state.activeDimension) btn.classList.add('active');
                btn.innerText = `${dim}D`;
                btn.onclick = () => switchDimension(dim);
                container.appendChild(btn);
            });
        }

        function switchDimension(dim) {
            if (dim === state.activeDimension) return;
            
            state.activeDimension = dim;
            state.pointsData.positions = state.viewMode === '2d' ?
                state.multiDimData2D[dim] :
                state.multiDimData3D[dim];
            
            updateDataCenter();
            updatePointsVisuals();
            updateAxes();
            updateCameraTarget();
            setupDimensionUI();
        }

        async function init() {
            try {
                initThree();
                await loadData();
                createPoints();
                setupUI();
                animate();
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error("Init error", error);
            }
        }

        init();

    </script>
</body>
</html>